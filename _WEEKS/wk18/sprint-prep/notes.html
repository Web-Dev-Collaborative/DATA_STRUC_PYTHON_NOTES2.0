<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="pandoc" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=yes"
    />
    <title>notes</title>
    <style type="text/css">
      code {
        white-space: pre-wrap;
      }
      span.smallcaps {
        font-variant: small-caps;
      }
      span.underline {
        text-decoration: underline;
      }
      div.column {
        display: inline-block;
        vertical-align: top;
        width: 50%;
      }
    </style>
    <style type="text/css">
      a.sourceLine {
        display: inline-block;
        line-height: 1.25;
      }
      a.sourceLine {
        pointer-events: none;
        color: inherit;
        text-decoration: inherit;
      }
      a.sourceLine:empty {
        height: 1.2em;
      }
      .sourceCode {
        overflow: visible;
      }
      code.sourceCode {
        white-space: pre;
        position: relative;
      }
      div.sourceCode {
        margin: 1em 0;
      }
      pre.sourceCode {
        margin: 0;
      }
      @media screen {
        div.sourceCode {
          overflow: auto;
        }
      }
      @media print {
        code.sourceCode {
          white-space: pre-wrap;
        }
        a.sourceLine {
          text-indent: -1em;
          padding-left: 1em;
        }
      }
      pre.numberSource a.sourceLine {
        position: relative;
        left: -4em;
      }
      pre.numberSource a.sourceLine::before {
        content: attr(title);
        position: relative;
        left: -1em;
        text-align: right;
        vertical-align: baseline;
        border: none;
        pointer-events: all;
        display: inline-block;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -khtml-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        padding: 0 4px;
        width: 4em;
        color: #aaaaaa;
      }
      pre.numberSource {
        margin-left: 3em;
        border-left: 1px solid #aaaaaa;
        padding-left: 4px;
      }
      div.sourceCode {
      }
      @media screen {
        a.sourceLine::before {
          text-decoration: underline;
        }
      }
      code span.al {
        color: #ff0000;
        font-weight: bold;
      } /* Alert */
      code span.an {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Annotation */
      code span.at {
        color: #7d9029;
      } /* Attribute */
      code span.bn {
        color: #40a070;
      } /* BaseN */
      code span.bu {
      } /* BuiltIn */
      code span.cf {
        color: #007020;
        font-weight: bold;
      } /* ControlFlow */
      code span.ch {
        color: #4070a0;
      } /* Char */
      code span.cn {
        color: #880000;
      } /* Constant */
      code span.co {
        color: #60a0b0;
        font-style: italic;
      } /* Comment */
      code span.cv {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* CommentVar */
      code span.do {
        color: #ba2121;
        font-style: italic;
      } /* Documentation */
      code span.dt {
        color: #902000;
      } /* DataType */
      code span.dv {
        color: #40a070;
      } /* DecVal */
      code span.er {
        color: #ff0000;
        font-weight: bold;
      } /* Error */
      code span.ex {
      } /* Extension */
      code span.fl {
        color: #40a070;
      } /* Float */
      code span.fu {
        color: #06287e;
      } /* Function */
      code span.im {
      } /* Import */
      code span.in {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Information */
      code span.kw {
        color: #007020;
        font-weight: bold;
      } /* Keyword */
      code span.op {
        color: #666666;
      } /* Operator */
      code span.ot {
        color: #007020;
      } /* Other */
      code span.pp {
        color: #bc7a00;
      } /* Preprocessor */
      code span.sc {
        color: #4070a0;
      } /* SpecialChar */
      code span.ss {
        color: #bb6688;
      } /* SpecialString */
      code span.st {
        color: #4070a0;
      } /* String */
      code span.va {
        color: #19177c;
      } /* Variable */
      code span.vs {
        color: #4070a0;
      } /* VerbatimString */
      code span.wa {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Warning */
    </style>
  </head>
  <body>
    <p>
      Two words are <em
        ><a href="https://en.wikipedia.org/wiki/Blanagram">blanagrams</a></em
      > if they are <a href="keyword://anagram">anagrams</a> but exactly one
      letter has been substituted for another.
    </p>
    <p>Given two words, check if they are <em>blanagrams</em> of each other.</p>
    <p>Example</p>
    <ul>
      <li>
        <p>
          For <code>word1 = "tangram"</code> and <code>word2 = "anagram"</code>,
          the output should be<br />
          <code>checkBlanagrams(word1, word2) = true</code>;
        </p>
        <p>
          After changing the first
          letter <code>'t'</code> to <code>'a'</code> in the <code>word1</code>,
          the words become anagrams.
        </p>
      </li>
      <li>
        <p>
          For <code>word1 = "tangram"</code> and <code>word2 = "pangram"</code>,
          the output should be<br />
          <code>checkBlanagrams(word1, word2) = true</code>.
        </p>
        <p>
          Since a word is an <em>anagram</em> of itself (a so-called <em
            >trivial anagram</em
          >), we are not obliged to rearrange letters. Only the substitution of
          a single letter is required for a word to be a <em>blanagram</em>, and
          here <code>'t'</code> is changed to <code>'p'</code>.
        </p>
      </li>
      <li>
        <p>
          For <code>word1 = "aba"</code> and <code>word2 = "bab"</code>, the
          output should be<br />
          <code>checkBlanagrams(word1, word2) = true</code>.
        </p>
        <p>
          You can take the first
          letter <code>'a'</code> of <code>word1</code> and change it
          to <code>'b'</code>, obtaining the word <code>"bba"</code>, which is
          an anagram of <code>word2 = "bab"</code>. It is also possible to
          change the first
          letter <code>'b'</code> of <code>word2</code> to <code>'a'</code> and
          obtain <code>"aab"</code>, which is an anagram of <code
            >word1 = "aba"</code
          >.
        </p>
      </li>
      <li>
        <p>
          For <code>word1 = "silent"</code> and <code>word2 = "listen"</code>,
          the output should be<br />
          <code>checkBlanagrams(word1, word2) = false</code>.
        </p>
        <p>
          These two words are <em>anagrams</em> of each other, but no letter
          substitution was made (the trivial substitution of a letter with
          itself shouldn’t be considered), so they are not <em>blanagrams</em>.
        </p>
      </li>
    </ul>
    <p>Input/Output</p>
    <ul>
      <li><p>[execution time limit] 4 seconds (py3)</p></li>
      <li>
        <p>[input] string word1</p>
        <p>A string consisting of lowercase letters.</p>
        <p>
          <em>Guaranteed constraints:</em><br />
          <code>1 ≤ word1.length ≤ 100</code>.
        </p>
      </li>
      <li>
        <p>[input] string word2</p>
        <p>A string consisting of lowercase letters.</p>
        <p>
          <em>Guaranteed constraints:</em><br />
          <code>word2.length = word1.length</code>.
        </p>
      </li>
      <li>
        <p>[output] boolean</p>
        <p>
          Return <code>true</code> if <code>word1</code> and <code>word2</code> are <em>blanagrams</em> of
          each other, otherwise return <code>false</code>.
        </p>
      </li>
    </ul>
    <h1 id="my-code-for-the-preceding-problem-was-as-follows">
      My code for the preceding problem was as follows:
    </h1>
    <div class="sourceCode" id="cb1">
      <pre
        class="sourceCode py"
      ><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1"></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="kw">def</span> checkBlanagrams(word1, word2):</a>
<a class="sourceLine" id="cb1-3" title="3">    lenWord1 <span class="op">=</span> <span class="bu">len</span>(word1)</a>
<a class="sourceLine" id="cb1-4" title="4">    lenWord2 <span class="op">=</span> <span class="bu">len</span>(word2)</a>
<a class="sourceLine" id="cb1-5" title="5">    freq1 <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> <span class="dv">26</span></a>
<a class="sourceLine" id="cb1-6" title="6">    freq2 <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> <span class="dv">26</span></a>
<a class="sourceLine" id="cb1-7" title="7">    count <span class="op">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb1-8" title="8">    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(lenWord1):</a>
<a class="sourceLine" id="cb1-9" title="9">        freq1[<span class="bu">ord</span>(word1[i]) <span class="op">-</span> <span class="bu">ord</span>(<span class="st">&#39;a&#39;</span>)] <span class="op">+=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb1-10" title="10">    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(lenWord2):</a>
<a class="sourceLine" id="cb1-11" title="11">        freq2[<span class="bu">ord</span>(word2[i]) <span class="op">-</span> <span class="bu">ord</span>(<span class="st">&#39;a&#39;</span>)] <span class="op">+=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb1-12" title="12">    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">26</span>):</a>
<a class="sourceLine" id="cb1-13" title="13">        count <span class="op">+=</span> <span class="bu">min</span>(freq1[i], freq2[i])</a>
<a class="sourceLine" id="cb1-14" title="14">    <span class="cf">return</span> count <span class="op">==</span> lenWord1<span class="dv">-1</span> <span class="op">==</span> lenWord2<span class="dv">-1</span></a>
<a class="sourceLine" id="cb1-15" title="15"><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&quot;__main__&quot;</span>:</a>
<a class="sourceLine" id="cb1-16" title="16">    <span class="bu">print</span>(checkBlanagrams(<span class="st">&#39;tangram&#39;</span>, <span class="st">&#39;anagram&#39;</span>))</a>
<a class="sourceLine" id="cb1-17" title="17"></a></code></pre>
    </div>
    <h2 id="conventions">Conventions:</h2>
    <blockquote>
      <p>
        the length of the words is represented by lenWord1 &amp; lenWord2
        respectively….
      </p>
    </blockquote>
    <blockquote>
      <p>
        freq1 &amp; freq2 are lists of length 26 (corresponding with the length
        of the alphabet) … (which we will use to calculate the frequency of each
        character that occurs in the words)… both are initially populated with
        the value 0
      </p>
    </blockquote>
    <blockquote>
      <p>count is a variable that stores the number of valid pairs</p>
    </blockquote>
    <p>
      <strong
        >The ord() function returns an integer representing the Unicode
        character.</strong
      >
    </p>
    <h4 id="the-loop">The loop:</h4>
    <div class="sourceCode" id="cb2">
      <pre
        class="sourceCode py"
      ><code class="sourceCode python"><a class="sourceLine" id="cb2-1" title="1">    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(lenWord1):</a>
<a class="sourceLine" id="cb2-2" title="2">        freq1[<span class="bu">ord</span>(word1[i]) <span class="op">-</span> <span class="bu">ord</span>(<span class="st">&#39;a&#39;</span>)] <span class="op">+=</span> <span class="dv">1</span></a></code></pre>
    </div>
    <h4
      id="will-be-used-to-update-the-frequencies-of-the-characters-of-string-word1"
    >
      will be used to update the frequencies of the characters of string word1
    </h4>
    <h5
      id="likewise-the-second-loop-shown-below-will-be-used-to-update-the-frequencies-of-the-characters-of-string-word2."
    >
      Likewise: the second loop shown below will be used to update the
      frequencies of the characters of string word2.
    </h5>
    <div class="sourceCode" id="cb3">
      <pre
        class="sourceCode py"
      ><code class="sourceCode python"><a class="sourceLine" id="cb3-1" title="1">    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(lenWord2):</a>
<a class="sourceLine" id="cb3-2" title="2">        freq2[<span class="bu">ord</span>(word2[i]) <span class="op">-</span> <span class="bu">ord</span>(<span class="st">&#39;a&#39;</span>)] <span class="op">+=</span> <span class="dv">1</span></a></code></pre>
    </div>
    <h4 id="the-third-loop">The third loop:</h4>
    <div class="sourceCode" id="cb4">
      <pre
        class="sourceCode py"
      ><code class="sourceCode python"><a class="sourceLine" id="cb4-1" title="1">    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">26</span>):</a>
<a class="sourceLine" id="cb4-2" title="2">        count <span class="op">+=</span> <span class="bu">min</span>(freq1[i], freq2[i])</a></code></pre>
    </div>
    <h4
      id="is-used-to-update-the-count-of-the-number-of-characters-in-each-string-that-have-the-same-frequency-as-each-other."
    >
      Is used to update the count of the number of characters in each string
      that have the same frequency as each other.
    </h4>
    <h4 id="finally">Finally:</h4>
    <div class="sourceCode" id="cb5">
      <pre
        class="sourceCode py"
      ><code class="sourceCode python"><a class="sourceLine" id="cb5-1" title="1">    <span class="cf">return</span> count <span class="op">==</span> lenWord1<span class="dv">-1</span> <span class="op">==</span> lenWord2<span class="dv">-1</span></a></code></pre>
    </div>
    <h3
      id="we-return-the-boolean-expression-evaluating-if-the-number-of-common-characters-between-the-strings-is-equal-to-the-length-of-the-strings-minus-the-one-overlapping-string-that-should-differ-as-per-the-definition-of-a-blanagram."
    >
      We return the boolean expression evaluating if the number of common
      characters between the strings is equal to the length of the strings minus
      the one overlapping string that should differ as per the definition of a
      Blanagram.
    </h3>
    <h2
      id="the-only-real-difficulty-i-encountered-was-knowing-where-to-start-as-i-initially-attempted-to-use-python-libraries-and-other-builtin-functions-like-zip-before-settling-on-doing-a-fully-native-implementation."
    >
      The only real difficulty I encountered was knowing where to start… as I
      initially attempted to use python libraries and other builtin functions
      like zip() … before settling on doing a fully native implementation.
    </h2>
    <h1 id="code">Code:</h1>
    <div class="sourceCode" id="cb6">
      <pre
        class="sourceCode py"
      ><code class="sourceCode python"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">def</span> checkBlanagrams(word1, word2):</a>
<a class="sourceLine" id="cb6-2" title="2">    lenWord1 <span class="op">=</span> <span class="bu">len</span>(word1)</a>
<a class="sourceLine" id="cb6-3" title="3">    lenWord2 <span class="op">=</span> <span class="bu">len</span>(word2)</a>
<a class="sourceLine" id="cb6-4" title="4">    freq1 <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> <span class="dv">26</span></a>
<a class="sourceLine" id="cb6-5" title="5">    freq2 <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> <span class="dv">26</span></a>
<a class="sourceLine" id="cb6-6" title="6">    count <span class="op">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb6-7" title="7">    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(lenWord1):</a>
<a class="sourceLine" id="cb6-8" title="8">        freq1[<span class="bu">ord</span>(word1[i]) <span class="op">-</span> <span class="bu">ord</span>(<span class="st">&#39;a&#39;</span>)] <span class="op">+=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb6-9" title="9">    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(lenWord2):</a>
<a class="sourceLine" id="cb6-10" title="10">        freq2[<span class="bu">ord</span>(word2[i]) <span class="op">-</span> <span class="bu">ord</span>(<span class="st">&#39;a&#39;</span>)] <span class="op">+=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb6-11" title="11">    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">26</span>):</a>
<a class="sourceLine" id="cb6-12" title="12">        count <span class="op">+=</span> <span class="bu">min</span>(freq1[i], freq2[i])</a>
<a class="sourceLine" id="cb6-13" title="13">    <span class="cf">return</span> count <span class="op">==</span> lenWord1<span class="dv">-1</span> <span class="op">==</span> lenWord2<span class="dv">-1</span></a>
<a class="sourceLine" id="cb6-14" title="14"><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&quot;__main__&quot;</span>:</a>
<a class="sourceLine" id="cb6-15" title="15">    <span class="bu">print</span>(checkBlanagrams(<span class="st">&#39;tangram&#39;</span>, <span class="st">&#39;anagram&#39;</span>))</a></code></pre>
    </div>
    <h1 id="time-complexity-on1-n2">Time Complexity: O(n1 + n2)</h1>
    <h1 id="space-complexity-o1">Space Complexity: O(1)</h1>
    <blockquote>
      <p>here n1 and n2 are the lengths of word1 and word2 respectively…</p>
    </blockquote>
    <hr />
    <blockquote>
      <p>
        Some list methods perform the same number of basic operations,
        irrespective of list size, so use constant time complexity of O(1). For
        other list methods, the number of operations they perform is
        proportional to the number of items in the list, so use linear time
        complexity of O(n).
      </p>
    </blockquote>
    <table>
      <thead>
        <tr class="header">
          <th>Operation</th>
          <th>Example</th>
          <th>Big-O</th>
        </tr>
      </thead>
      <tbody>
        <tr class="odd">
          <td>Index</td>
          <td>list[0]</td>
          <td>O(1)</td>
        </tr>
        <tr class="even">
          <td>Store</td>
          <td>list[0] = 0</td>
          <td>O(1)</td>
        </tr>
        <tr class="odd">
          <td>Append</td>
          <td>list.append(4)</td>
          <td>O(1)</td>
        </tr>
        <tr class="even">
          <td>Pop</td>
          <td>list.pop()</td>
          <td>O(1)</td>
        </tr>
        <tr class="odd">
          <td>Clear</td>
          <td>list.clear()</td>
          <td>O(1)</td>
        </tr>
        <tr class="even">
          <td>Length</td>
          <td>len(list)</td>
          <td>O(1)</td>
        </tr>
        <tr class="odd">
          <td>Pop Index</td>
          <td>list.pop(0)</td>
          <td>O(n)</td>
        </tr>
        <tr class="even">
          <td>Remove</td>
          <td>list.remove(‘x’)</td>
          <td>O(n)</td>
        </tr>
        <tr class="odd">
          <td>Insert</td>
          <td>list.insert(0,‘a’)</td>
          <td>O(n)</td>
        </tr>
        <tr class="even">
          <td>Del operator</td>
          <td>del list</td>
          <td>O(n)</td>
        </tr>
        <tr class="odd">
          <td>Iteration</td>
          <td>for v in list:</td>
          <td>O(n)</td>
        </tr>
        <tr class="even">
          <td>Containment</td>
          <td>‘x’ in list1</td>
          <td>O(n)</td>
        </tr>
        <tr class="odd">
          <td>Equality</td>
          <td>list1 == list2</td>
          <td>O(n)</td>
        </tr>
        <tr class="even">
          <td>Copy</td>
          <td>list.copy()</td>
          <td>O(n)</td>
        </tr>
        <tr class="odd">
          <td>Reverse</td>
          <td>list.reverse()</td>
          <td>O(n)</td>
        </tr>
        <tr class="even">
          <td>get slice [x:y]</td>
          <td>list[a:b]</td>
          <td>O(k)</td>
        </tr>
        <tr class="odd">
          <td>del slice</td>
          <td>del list[a:b]</td>
          <td>O(n)</td>
        </tr>
        <tr class="even">
          <td>set slice</td>
          <td></td>
          <td>O(n+k)</td>
        </tr>
        <tr class="odd">
          <td>concatenate</td>
          <td></td>
          <td>O(k)</td>
        </tr>
        <tr class="even">
          <td>Sort</td>
          <td>list.sort()</td>
          <td>O(n log n)</td>
        </tr>
        <tr class="odd">
          <td>Multiply</td>
          <td>5 * list</td>
          <td>O(k n)</td>
        </tr>
      </tbody>
    </table>
    <p>
      Even though there are three loops in my solution none of them are nested
      and they each scale with the length of the words provided… thus their time
      complexity reduces to:
    </p>
    <h1 id="on1-n2-on">O(n1 + n2) ≈ O(n)</h1>
    <p>
      For iterative algorithms we have to consider the variables and the
      respective abstract (or native) data structures we assign to them. For
      example declaring an list of size n would add to the space complexity by a
      factor of O(n)…
    </p>
    <h3
      id="since-we-declare-lists-of-a-fixed-or-constant-length-of-26-our-space-complexity-is-o1"
    >
      Since we declare lists of a fixed (or constant) length of 26… our space
      complexity is O(1)
    </h3>
    <pre><code>---
---</code></pre>
    <h2
      id="you-are-given-a-sorted-array-in-ascending-order-that-is-rotated-at-some-unknown-pivot-i.e.-0124567-might-become-4567012-and-a-target-value."
    >
      You are given a sorted array in ascending order that is rotated at some
      unknown pivot (i.e., `[0,1,2,4,5,6,7]` might become `[4,5,6,7,0,1,2]`) and
      a target value.
    </h2>
    <h1
      id="write-a-function-that-returns-the-target-values-index.-if-the-target-value-is-not-present-in-the-array-return--1."
    >
      Write a function that returns the target value’s index. If the target
      value is not present in the array, return -1.
    </h1>
    <p>You may assume no duplicate exists in the array.</p>
    <p>Your algorithm’s runtime complexity must be in the order of O(log n).</p>
    <p>Example 1:</p>
    <p>
      Input: <code>nums = [4,5,6,7,0,1,2], target = 0</code><br />
      Output: <code>4</code>
    </p>
    <p>Example 2:</p>
    <p>
      Input: <code>nums = [4,5,6,7,0,1,2], target = 3</code><br />
      Output: <code>-1</code>
    </p>
    <ul>
      <li><p>[execution time limit] 4 seconds (py3)</p></li>
      <li><p>[input] array.integer nums</p></li>
      <li><p>[input] integer target</p></li>
      <li><p>[output] integer</p></li>
    </ul>
    <hr />
    <hr />
    <pre><code>---
---</code></pre>
    <p>
      Search a sorted array by repeatedly dividing the search interval in half.
      Begin with an interval covering the whole array. If the value of the
      search key is less than the item in the middle of the interval, narrow the
      interval to the lower half. Otherwise, narrow it to the upper half.
      Repeatedly check until the value is found or the interval is empty.
    </p>
    <p>
      The binary search algorithm breaks the list down in half on every
      iteration, rather than sequentially combing through the list. On large
      lists, this method can be really useful.
    </p>
    <p>
      The time complexity of the binary search algorithm is O(log n). The
      best-case time complexity would be O(1) when the central index would
      directly match the desired value. The worst-case scenario could be the
      values at either extremity of the list or values not in the list.
    </p>
    <hr />
    <hr />
    <pre><code>---
---</code></pre>
    <hr />
    <hr />
  </body>
</html>
